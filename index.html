<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saint's ETH/USDT Trading Bot</title>
    <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --bg-color: #121826;
            --panel-color: #1e293b;
            --text-color: #e0e0e0;
            --accent-color: #3b82f6;
            --profit-color: #4ade80;
            --loss-color: #f87171;
            --border-color: #334155;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
        }
        
        .container {
            display: grid;
            grid-template-rows: auto auto auto auto;
            gap: 15px;
            padding: 15px;
            max-width: 100%;
        }
        
        .header {
            text-align: center;
            padding: 10px;
            background: var(--panel-color);
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        h1 {
            margin: 0;
            font-size: 1.4rem;
            color: var(--accent-color);
        }
        
        .chart-container {
            background: var(--panel-color);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .panel {
            background: var(--panel-color);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .panel-title {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.2rem;
            color: #f8fafc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        button:hover {
            background-color: #2563eb;
        }
        
        button:disabled {
            background-color: #64748b;
            cursor: not-allowed;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .btn-group button {
            flex: 1;
        }
        
        .checklist-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 5px;
            background-color: #334155;
            font-size: 0.9rem;
        }
        
        .checklist-item input {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .checklist-item.checked {
            background-color: #1e3a8a;
        }
        
        .signal {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .buy-signal {
            background-color: rgba(74, 222, 128, 0.15);
            border-left: 4px solid var(--profit-color);
        }
        
        .sell-signal {
            background-color: rgba(248, 113, 113, 0.15);
            border-left: 4px solid var(--loss-color);
        }
        
        .trade-history {
            max-height: 200px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .trade {
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            background-color: #334155;
            font-size: 0.85rem;
        }
        
        .profit {
            color: var(--profit-color);
        }
        
        .loss {
            color: var(--loss-color);
        }
        
        .account-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .account-info-item {
            background-color: #334155;
            padding: 8px;
            border-radius: 5px;
        }
        
        .account-info-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 3px;
        }
        
        .timeframe-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            overflow-x: auto;
            padding-bottom: 5px;
            -webkit-overflow-scrolling: touch;
        }
        
        .timeframe-btn {
            flex: none;
            padding: 8px 12px;
            background-color: #334155;
            border: 1px solid #475569;
            font-size: 0.8rem;
        }
        
        .timeframe-btn.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        
        #chart {
            width: 100%;
            height: 300px;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid #334155;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom: 2px solid var(--accent-color);
            color: var(--accent-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .settings-item {
            margin-bottom: 15px;
        }
        
        .settings-label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .settings-input {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #475569;
            background-color: #334155;
            color: var(--text-color);
        }
        
        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .header {
                grid-column: 1 / -1;
            }
            
            .chart-container {
                grid-row: 2;
                height: calc(100vh - 200px);
            }
            
            #chart {
                height: calc(100% - 50px);
            }
            
            .trade-history {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Saint's ETH/USDT Trading Bot</h1>
            <p>Follows the trend, waits for pullbacks, manages risk</p>
        </div>
        
        <div class="chart-container">
            <div class="timeframe-selector">
                <button class="timeframe-btn" data-tf="1h">1H</button>
                <button class="timeframe-btn" data-tf="15m">15M</button>
                <button class="timeframe-btn active" data-tf="5m">5M</button>
                <button class="timeframe-btn" data-tf="1m">1M</button>
            </div>
            <div id="chart"></div>
        </div>
        
        <div class="panel account-panel">
            <h2 class="panel-title">$20 Challenge Account</h2>
            <div class="account-info">
                <div class="account-info-item">
                    <div class="account-info-label">Balance</div>
                    <div id="balance">20.00</div>
                </div>
                <div class="account-info-item">
                    <div class="account-info-label">Risk Amount (2%)</div>
                    <div id="risk-amount">0.40</div>
                </div>
                <div class="account-info-item">
                    <div class="account-info-label">Trades</div>
                    <div id="trade-count">0</div>
                </div>
                <div class="account-info-item">
                    <div class="account-info-label">Win Rate</div>
                    <div id="win-rate">0%</div>
                </div>
            </div>
            <div class="account-info">
                <div class="account-info-item">
                    <div class="account-info-label">Position Size</div>
                    <div id="position-size">0 ETH</div>
                </div>
                <div class="account-info-item">
                    <div class="account-info-label">Leverage</div>
                    <div id="leverage">10x</div>
                </div>
            </div>
            <div class="btn-group">
                <button id="manual-buy">Buy</button>
                <button id="manual-sell">Sell</button>
                <button id="close-position" disabled>Close</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="tab-container">
                <div class="tab active" data-tab="checklist">Checklist</div>
                <div class="tab" data-tab="signals">Signals</div>
                <div class="tab" data-tab="history">History</div>
                <div class="tab" data-tab="settings">Settings</div>
            </div>
            
            <div class="tab-content active" id="checklist-tab">
                <div id="checklist">
                    <div class="checklist-item">
                        <input type="checkbox" id="trend-confirmed">
                        <label for="trend-confirmed">Trend confirmed (HH/HL or LH/LL)</label>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="price-ema">
                        <label for="price-ema">Price above/below 50 EMA</label>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="sr-levels">
                        <label for="sr-levels">Key S/R levels marked</label>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="pullback">
                        <label for="pullback">Pullback/consolidation visible</label>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="volume-confirm">
                        <label for="volume-confirm">Volume confirms direction</label>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="rsi-confirm">
                        <label for="rsi-confirm">RSI shows exhaustion (30/70)</label>
                    </div>
                    <div class="checklist-item">
                        <input type="checkbox" id="macd-confirm">
                        <label for="macd-confirm">MACD shows momentum shift</label>
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <button id="auto-trade" disabled>Auto Trade (0/7)</button>
                </div>
            </div>
            
            <div class="tab-content" id="signals-tab">
                <div id="signals-container"></div>
            </div>
            
            <div class="tab-content" id="history-tab">
                <div class="trade-history" id="trades-container"></div>
            </div>
            
            <div class="tab-content" id="settings-tab">
                <div class="settings-item">
                    <label class="settings-label">Account Size (USDT)</label>
                    <input type="number" id="account-size" class="settings-input" value="20" min="10" step="1">
                </div>
                <div class="settings-item">
                    <label class="settings-label">Risk per Trade (%)</label>
                    <input type="number" id="risk-percent" class="settings-input" value="2" min="0.5" max="5" step="0.5">
                </div>
                <div class="settings-item">
                    <label class="settings-label">Leverage</label>
                    <select id="leverage-select" class="settings-input">
                        <option value="5">5x</option>
                        <option value="10" selected>10x</option>
                        <option value="20">20x</option>
                    </select>
                </div>
                <div class="settings-item">
                    <label class="settings-label">Auto-Trading</label>
                    <select id="auto-trading" class="settings-input">
                        <option value="off">Disabled</option>
                        <option value="on">Enabled</option>
                        <option value="notify">Signals Only</option>
                    </select>
                </div>
                <button id="save-settings">Save Settings</button>
            </div>
        </div>
    </div>

    <script>
        // Trading Account State
        const tradingAccount = {
            balance: 20.00,
            trades: [],
            currentPosition: null,
            leverage: 10,
            riskPercentage: 2,
            winCount: 0,
            autoTrading: 'notify',
            settings: {
                accountSize: 20,
                riskPercent: 2,
                leverage: 10,
                autoTrading: 'notify'
            }
        };

        // Chart and Data Variables
        let chart;
        let candleSeries;
        let volumeSeries;
        let rsiSeries;
        let macdSeries;
        let currentTimeframe = '5m';
        let ethPrice = 0;
        let lastCandle = null;
        let candlesData = [];
        let rsiData = [];
        let macdData = [];
        let ema50Data = [];
        let srLevels = [];
        let websocket = null;

        // DOM Elements
        const balanceEl = document.getElementById('balance');
        const riskAmountEl = document.getElementById('risk-amount');
        const tradeCountEl = document.getElementById('trade-count');
        const winRateEl = document.getElementById('win-rate');
        const positionSizeEl = document.getElementById('position-size');
        const leverageEl = document.getElementById('leverage');
        const manualBuyBtn = document.getElementById('manual-buy');
        const manualSellBtn = document.getElementById('manual-sell');
        const closePositionBtn = document.getElementById('close-position');
        const autoTradeBtn = document.getElementById('auto-trade');
        const checklistItems = document.querySelectorAll('.checklist-item input');
        const signalsContainer = document.getElementById('signals-container');
        const tradesContainer = document.getElementById('trades-container');
        const timeframeBtns = document.querySelectorAll('.timeframe-btn');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');

        // Settings DOM Elements
        const accountSizeInput = document.getElementById('account-size');
        const riskPercentInput = document.getElementById('risk-percent');
        const leverageSelect = document.getElementById('leverage-select');
        const autoTradingSelect = document.getElementById('auto-trading');
        const saveSettingsBtn = document.getElementById('save-settings');

        // Initialize the application
        async function init() {
            loadSettings();
            createChart();
            loadTradeHistory();
            updateAccountDisplay();
            await fetchInitialData();
            startWebSocket();
            setupEventListeners();
            startSignalCheckInterval();
        }

        // Create TradingView Lightweight Chart
        function createChart() {
            const chartContainer = document.getElementById('chart');
            chart = LightweightCharts.createChart(chartContainer, {
                layout: {
                    backgroundColor: '#1e293b',
                    textColor: '#e0e0e0',
                    fontSize: 12,
                },
                grid: {
                    vertLines: {
                        color: '#334155',
                    },
                    horzLines: {
                        color: '#334155',
                    },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#334155',
                },
                timeScale: {
                    borderColor: '#334155',
                    timeVisible: true,
                    secondsVisible: false,
                },
                localization: {
                    priceFormatter: price => parseFloat(price).toFixed(2),
                },
            });

            candleSeries = chart.addCandlestickSeries({
                upColor: '#4ade80',
                downColor: '#f87171',
                borderDownColor: '#f87171',
                borderUpColor: '#4ade80',
                wickDownColor: '#f87171',
                wickUpColor: '#4ade80',
            });

            volumeSeries = chart.addHistogramSeries({
                color: '#60a5fa',
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: '',
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                },
            });

            rsiSeries = chart.addLineSeries({
                color: '#f59e0b',
                lineWidth: 2,
                priceScaleId: 'rsi',
            });

            macdSeries = chart.addLineSeries({
                color: '#8b5cf6',
                lineWidth: 2,
                priceScaleId: 'macd',
            });

            // Add 50 EMA series
            chart.addLineSeries({
                color: '#3b82f6',
                lineWidth: 2,
            });

            // Price scale configuration
            chart.priceScale('right').applyOptions({
                scaleMargins: {
                    top: 0.2,
                    bottom: 0.2,
                },
            });

            chart.priceScale('rsi').applyOptions({
                scaleMargins: {
                    top: 0.7,
                    bottom: 0,
                },
            });

            chart.priceScale('macd').applyOptions({
                scaleMargins: {
                    top: 0.7,
                    bottom: 0,
                },
            });
        }

        // Fetch initial historical data
        async function fetchInitialData() {
            try {
                showLoading('Loading chart data...');
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=ETHUSDT&interval=${currentTimeframe}&limit=100`);
                const data = await response.json();
                
                candlesData = data.map(item => ({
                    time: item[0] / 1000,
                    open: parseFloat(item[1]),
                    high: parseFloat(item[2]),
                    low: parseFloat(item[3]),
                    close: parseFloat(item[4]),
                    volume: parseFloat(item[5]),
                }));
                
                lastCandle = candlesData[candlesData.length - 1];
                ethPrice = lastCandle.close;
                
                // Calculate indicators
                calculateIndicators();
                
                // Update chart
                candleSeries.setData(candlesData);
                volumeSeries.setData(candlesData.map(candle => ({
                    time: candle.time,
                    value: candle.volume,
                    color: candle.close >= candle.open ? 'rgba(74, 222, 128, 0.5)' : 'rgba(248, 113, 113, 0.5)',
                })));
                
                rsiSeries.setData(rsiData);
                macdSeries.setData(macdData);
                
                // Mark key S/R levels (simplified for demo)
                identifySupportResistance();
                
                hideLoading();
            } catch (error) {
                console.error('Error fetching initial data:', error);
                hideLoading();
                showError('Failed to load chart data. Please refresh.');
            }
        }

        // Calculate technical indicators
        function calculateIndicators() {
            // Calculate RSI (14 period)
            rsiData = calculateRSI(candlesData, 14);
            
            // Calculate MACD (12, 26, 9)
            macdData = calculateMACD(candlesData, 12, 26, 9);
            
            // Calculate 50 EMA
            ema50Data = calculateEMA(candlesData, 50);
        }

        // Simplified RSI calculation
        function calculateRSI(data, period) {
            const rsi = [];
            let gains = 0;
            let losses = 0;
            
            for (let i = 1; i <= period; i++) {
                const change = data[i].close - data[i - 1].close;
                if (change >= 0) gains += change;
                else losses -= change;
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;
            let rs = avgGain / avgLoss;
            rsi.push({ time: data[period].time, value: 100 - (100 / (1 + rs)) });
            
            for (let i = period + 1; i < data.length; i++) {
                const change = data[i].close - data[i - 1].close;
                let currentGain = 0;
                let currentLoss = 0;
                
                if (change >= 0) currentGain = change;
                else currentLoss = -change;
                
                avgGain = (avgGain * (period - 1) + currentGain) / period;
                avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
                
                rs = avgGain / avgLoss;
                rsi.push({ time: data[i].time, value: 100 - (100 / (1 + rs)) });
            }
            
            return rsi;
        }

        // Simplified MACD calculation
        function calculateMACD(data, fastPeriod, slowPeriod, signalPeriod) {
            const emaFast = calculateEMA(data, fastPeriod);
            const emaSlow = calculateEMA(data, slowPeriod);
            
            // Calculate MACD line (fast EMA - slow EMA)
            const macdLine = [];
            for (let i = 0; i < emaSlow.length; i++) {
                macdLine.push({
                    time: emaSlow[i].time,
                    value: emaFast[i].value - emaSlow[i].value
                });
            }
            
            // Calculate signal line (EMA of MACD line)
            const signalLine = calculateEMA(macdLine, signalPeriod);
            
            // For simplicity, we'll just return the MACD line
            return macdLine;
        }

        // EMA calculation
        function calculateEMA(data, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            // Calculate SMA for first point
            let sum = 0;
            for (let i = 0; i < period; i++) {
                sum += data[i].close;
            }
            ema.push({ time: data[period - 1].time, value: sum / period });
            
            // Calculate EMA for subsequent points
            for (let i = period; i < data.length; i++) {
                const emaValue = (data[i].close - ema[ema.length - 1].value) * multiplier + ema[ema.length - 1].value;
                ema.push({ time: data[i].time, value: emaValue });
            }
            
            return ema;
        }

        // Identify key support/resistance levels (simplified)
        function identifySupportResistance() {
            srLevels = [];
            
            // Find swing highs and lows
            const swingPoints = [];
            for (let i = 2; i < candlesData.length - 2; i++) {
                const prev1 = candlesData[i - 1];
                const prev2 = candlesData[i - 2];
                const current = candlesData[i];
                const next1 = candlesData[i + 1];
                const next2 = candlesData[i + 2];
                
                // Swing high
                if (current.high > prev1.high && current.high > prev2.high && 
                    current.high > next1.high && current.high > next2.high) {
                    swingPoints.push({
                        time: current.time,
                        price: current.high,
                        type: 'resistance'
                    });
                }
                
                // Swing low
                if (current.low < prev1.low && current.low < prev2.low && 
                    current.low < next1.low && current.low < next2.low) {
                    swingPoints.push({
                        time: current.time,
                        price: current.low,
                        type: 'support'
                    });
                }
            }
            
            // Cluster nearby levels
            const clusterThreshold = ethPrice * 0.01; // 1% of current price
            const clusteredLevels = [];
            
            for (const point of swingPoints) {
                let foundCluster = false;
                
                for (const cluster of clusteredLevels) {
                    if (Math.abs(point.price - cluster.price) <= clusterThreshold) {
                        cluster.points.push(point);
                        foundCluster = true;
                        break;
                    }
                }
                
                if (!foundCluster) {
                    clusteredLevels.push({
                        price: point.price,
                        type: point.type,
                        points: [point]
                    });
                }
            }
            
            // Sort by number of points in cluster
            clusteredLevels.sort((a, b) => b.points.length - a.points.length);
            
            // Take top 3 support and resistance levels
            const supports = clusteredLevels.filter(l => l.type === 'support').slice(0, 3);
            const resistances = clusteredLevels.filter(l => l.type === 'resistance').slice(0, 3);
            
            srLevels = [...supports, ...resistances];
            
            // Draw levels on chart (simplified for demo)
            srLevels.forEach(level => {
                const line = {
                    price: level.price,
                    color: level.type === 'support' ? '#4ade80' : '#f87171',
                    lineWidth: 1,
                    lineStyle: 2, // Dashed
                    axisLabelVisible: true,
                    title: level.type === 'support' ? 'S' : 'R',
                };
                
                chart.createPriceLine(line);
            });
        }

        // Start WebSocket connection for real-time data
        function startWebSocket() {
            if (websocket) {
                websocket.close();
            }
            
            websocket = new WebSocket(`wss://stream.binance.com:9443/ws/ethusdt@kline_${currentTimeframe}`);
            
            websocket.onmessage = (event) => {
                const message = JSON.parse(event.data);
                const candle = message.k;
                
                const newCandle = {
                    time: candle.t / 1000,
                    open: parseFloat(candle.o),
                    high: parseFloat(candle.h),
                    low: parseFloat(candle.l),
                    close: parseFloat(candle.c),
                    volume: parseFloat(candle.v),
                    isClosed: candle.x
                };
                
                if (newCandle.isClosed) {
                    // Replace last candle with new closed candle
                    candlesData[candlesData.length - 1] = newCandle;
                    candlesData.push(newCandle); // Add new candle
                    candlesData.shift(); // Remove oldest candle to maintain 100 candles
                    
                    lastCandle = newCandle;
                    ethPrice = newCandle.close;
                    
                    // Recalculate indicators
                    calculateIndicators();
                    
                    // Update chart
                    candleSeries.update(newCandle);
                    volumeSeries.update({
                        time: newCandle.time,
                        value: newCandle.volume,
                        color: newCandle.close >= newCandle.open ? 'rgba(74, 222, 128, 0.5)' : 'rgba(248, 113, 113, 0.5)',
                    });
                    
                    // Update RSI and MACD
                    rsiSeries.update(rsiData[rsiData.length - 1]);
                    macdSeries.update(macdData[macdData.length - 1]);
                    
                    // Check for new signals
                    checkTradingSignals();
                } else {
                    // Update current candle
                    candleSeries.update(newCandle);
                    volumeSeries.update({
                        time: newCandle.time,
                        value: newCandle.volume,
                        color: newCandle.close >= newCandle.open ? 'rgba(74, 222, 128, 0.5)' : 'rgba(248, 113, 113, 0.5)',
                    });
                    
                    lastCandle = newCandle;
                    ethPrice = newCandle.close;
                    
                    // Check if we need to close position due to stop loss/take profit
                    checkPositionExit();
                }
            };
            
            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                showError('Connection error. Reconnecting...');
                setTimeout(startWebSocket, 5000);
            };
            
            websocket.onclose = () => {
                console.log('WebSocket closed. Reconnecting...');
                setTimeout(startWebSocket, 5000);
            };
        }

        // Check for trading signals based on strategy
        function checkTradingSignals() {
            if (candlesData.length < 50) return; // Not enough data
            
            const currentRsi = rsiData[rsiData.length - 1].value;
            const currentMacd = macdData[macdData.length - 1].value;
            const prevMacd = macdData[macdData.length - 2].value;
            const currentEma50 = ema50Data[ema50Data.length - 1].value;
            
            // Determine trend direction
            let trendDirection = 'neutral';
            if (ethPrice > currentEma50) {
                // Check for uptrend (HH/HL)
                if (candlesData[candlesData.length - 1].high > candlesData[candlesData.length - 2].high &&
                    candlesData[candlesData.length - 2].low > candlesData[candlesData.length - 3].low) {
                    trendDirection = 'up';
                }
            } else {
                // Check for downtrend (LH/LL)
                if (candlesData[candlesData.length - 1].low < candlesData[candlesData.length - 2].low &&
                    candlesData[candlesData.length - 2].high < candlesData[candlesData.length - 3].high) {
                    trendDirection = 'down';
                }
            }
            
            // Check for buy signals (in uptrend)
            if (trendDirection === 'up') {
                // Price pulled back to support
                const nearestSupport = srLevels
                    .filter(l => l.type === 'support' && l.price < ethPrice)
                    .sort((a, b) => b.price - a.price)[0];
                
                if (nearestSupport && Math.abs(ethPrice - nearestSupport.price) < ethPrice * 0.005) {
                    // RSI conditions
                    const rsiCondition = currentRsi < 35 && rsiData[rsiData.length - 2].value < currentRsi;
                    
                    // MACD conditions
                    const macdCondition = currentMacd > prevMacd && currentMacd < 0;
                    
                    if (rsiCondition && macdCondition) {
                        const signal = {
                            type: 'buy',
                            price: ethPrice,
                            time: new Date().toISOString(),
                            reason: `Bounce off support at ${nearestSupport.price.toFixed(2)}, RSI ${currentRsi.toFixed(2)} rising from oversold, MACD turning up`
                        };
                        
                        addSignal(signal);
                        
                        // Auto trade if enabled and checklist is complete
                        if (tradingAccount.autoTrading === 'on' && autoTradeBtn.disabled === false) {
                            executeTrade('buy', signal.reason);
                        }
                    }
                }
            }
            
            // Check for sell signals (in downtrend)
            if (trendDirection === 'down') {
                // Price pulled back to resistance
                const nearestResistance = srLevels
                    .filter(l => l.type === 'resistance' && l.price > ethPrice)
                    .sort((a, b) => a.price - b.price)[0];
                
                if (nearestResistance && Math.abs(ethPrice - nearestResistance.price) < ethPrice * 0.005) {
                    // RSI conditions
                    const rsiCondition = currentRsi > 65 && rsiData[rsiData.length - 2].value > currentRsi;
                    
                    // MACD conditions
                    const macdCondition = currentMacd < prevMacd && currentMacd > 0;
                    
                    if (rsiCondition && macdCondition) {
                        const signal = {
                            type: 'sell',
                            price: ethPrice,
                            time: new Date().toISOString(),
                            reason: `Rejection at resistance ${nearestResistance.price.toFixed(2)}, RSI ${currentRsi.toFixed(2)} falling from overbought, MACD turning down`
                        };
                        
                        addSignal(signal);
                        
                        // Auto trade if enabled and checklist is complete
                        if (tradingAccount.autoTrading === 'on' && autoTradeBtn.disabled === false) {
                            executeTrade('sell', signal.reason);
                        }
                    }
                }
            }
        }

        // Check if we need to close position due to stop loss/take profit
        function checkPositionExit() {
            if (!tradingAccount.currentPosition) return;
            
            const position = tradingAccount.currentPosition;
            
            if (position.type === 'buy') {
                // Check take profit
                if (ethPrice >= position.takeProfit) {
                    closePositionWithReason(`Take profit hit at ${position.takeProfit.toFixed(2)}`);
                    return;
                }
                
                // Check stop loss
                if (ethPrice <= position.stopLoss) {
                    closePositionWithReason(`Stop loss hit at ${position.stopLoss.toFixed(2)}`);
                    return;
                }
            } else {
                // Check take profit
                if (ethPrice <= position.takeProfit) {
                    closePositionWithReason(`Take profit hit at ${position.takeProfit.toFixed(2)}`);
                    return;
                }
                
                // Check stop loss
                if (ethPrice >= position.stopLoss) {
                    closePositionWithReason(`Stop loss hit at ${position.stopLoss.toFixed(2)}`);
                    return;
                }
            }
        }

        // Close position with a specific reason
        function closePositionWithReason(reason) {
            const position = tradingAccount.currentPosition;
            position.exitReason = reason;
            closePosition();
        }

        // Add signal to UI
        function addSignal(signal) {
            // Check if similar signal was already shown recently
            const recentSignals = Array.from(signalsContainer.children)
                .filter(el => el.className.includes(`${signal.type}-signal`))
                .slice(0, 3);
                
            for (const recentSignal of recentSignals) {
                const recentPrice = parseFloat(recentSignal.querySelector('span').textContent.split('@')[1]);
                if (Math.abs(recentPrice - signal.price) < ethPrice * 0.002) {
                    return; // Skip very similar signals
                }
            }
            
            const signalEl = document.createElement('div');
            signalEl.className = `signal ${signal.type}-signal`;
            
            const typeEl = document.createElement('strong');
            typeEl.textContent = signal.type.toUpperCase();
            
            const priceEl = document.createElement('span');
            priceEl.textContent = ` @ ${signal.price.toFixed(2)}`;
            
            const reasonEl = document.createElement('p');
            reasonEl.textContent = signal.reason;
            
            const timeEl = document.createElement('small');
            timeEl.textContent = new Date(signal.time).toLocaleTimeString();
            
            signalEl.appendChild(typeEl);
            signalEl.appendChild(priceEl);
            signalEl.appendChild(reasonEl);
            signalEl.appendChild(timeEl);
            
            signalsContainer.insertBefore(signalEl, signalsContainer.firstChild);
            
            // Play sound for new signal
            playNotificationSound();
            
            // Show notification if in background
            if (document.hidden && Notification.permission === 'granted') {
                new Notification(`ETH ${signal.type.toUpperCase()} Signal`, {
                    body: signal.reason,
                    icon: 'https://cryptologos.cc/logos/ethereum-eth-logo.png'
                });
            }
            
            // Limit to 10 signals
            if (signalsContainer.children.length > 10) {
                signalsContainer.removeChild(signalsContainer.lastChild);
            }
        }

        // Play notification sound
        function playNotificationSound() {
            const audio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3');
            audio.volume = 0.2;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }

        // Execute a trade
        function executeTrade(type, reason) {
            if (tradingAccount.currentPosition) {
                console.log('Already in a position');
                return;
            }
            
            const riskAmount = tradingAccount.balance * (tradingAccount.riskPercentage / 100);
            const positionSize = (riskAmount / (ethPrice * 0.01)) * tradingAccount.leverage; // 1% stop loss with leverage
            
            const trade = {
                id: Date.now(),
                type,
                entryPrice: ethPrice,
                entryTime: new Date().toISOString(),
                positionSize,
                stopLoss: type === 'buy' ? ethPrice * 0.99 : ethPrice * 1.01,
                takeProfit: type === 'buy' ? ethPrice * 1.02 : ethPrice * 0.98,
                reason,
                status: 'open',
                exitPrice: null,
                exitTime: null,
                exitReason: null,
                pnl: null
            };
            
            tradingAccount.currentPosition = trade;
            updateAccountDisplay();
            addTradeToHistory(trade);
            
            // Show trade confirmation
            const signalEl = document.createElement('div');
            signalEl.className = `signal ${type}-signal`;
            signalEl.innerHTML = `<strong>TRADE EXECUTED: ${type.toUpperCase()}</strong> @ ${ethPrice.toFixed(2)}<br>
                                <small>${reason}</small>`;
            signalsContainer.insertBefore(signalEl, signalsContainer.firstChild);
            
            // Play sound for trade execution
            playTradeSound();
        }

        // Play trade execution sound
        function playTradeSound() {
            const audio = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-beep-221.mp3');
            audio.volume = 0.3;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }

        // Close current position
        function closePosition() {
            if (!tradingAccount.currentPosition) return;
            
            const trade = tradingAccount.currentPosition;
            trade.exitPrice = ethPrice;
            trade.exitTime = new Date().toISOString();
            
            if (trade.type === 'buy') {
                trade.pnl = (trade.exitPrice - trade.entryPrice) * trade.positionSize;
            } else {
                trade.pnl = (trade.entryPrice - trade.exitPrice) * trade.positionSize;
            }
            
            trade.status = 'closed';
            tradingAccount.balance += trade.pnl;
            
            if (trade.pnl > 0) {
                tradingAccount.winCount++;
            }
            
            tradingAccount.currentPosition = null;
            tradingAccount.trades.push(trade);
            updateAccountDisplay();
            updateTradeInHistory(trade);
            saveTradeHistory();
            
            // Show trade closure
            const signalEl = document.createElement('div');
            signalEl.className = `signal ${trade.pnl > 0 ? 'buy' : 'sell'}-signal`;
            
            let closeReason = trade.exitReason || 'Manual close';
            if (trade.pnl > 0) {
                closeReason = 'Profit taken: ' + closeReason;
            } else {
                closeReason = 'Loss stopped: ' + closeReason;
            }
            
            signalEl.innerHTML = `<strong>POSITION CLOSED: ${trade.type.toUpperCase()}</strong> @ ${ethPrice.toFixed(2)}<br>
                                <small>${closeReason}</small><br>
                                <small>PNL: ${trade.pnl.toFixed(2)} USDT (${((trade.pnl / (trade.entryPrice * trade.positionSize / tradingAccount.leverage)) * 100).toFixed(2)}%)</small>`;
            signalsContainer.insertBefore(signalEl, signalsContainer.firstChild);
        }

        // Add trade to history UI
        function addTradeToHistory(trade) {
            const tradeEl = document.createElement('div');
            tradeEl.className = 'trade';
            tradeEl.dataset.id = trade.id;
            
            const typeEl = document.createElement('strong');
            typeEl.textContent = trade.type.toUpperCase();
            typeEl.className = trade.type === 'buy' ? 'profit' : 'loss';
            
            const priceEl = document.createElement('span');
            priceEl.textContent = ` @ ${trade.entryPrice.toFixed(2)}`;
            
            const sizeEl = document.createElement('div');
            sizeEl.textContent = `Size: ${(trade.positionSize / tradingAccount.leverage).toFixed(4)} ETH (${trade.positionSize.toFixed(4)} with ${tradingAccount.leverage}x)`;
            
            const slTpEl = document.createElement('div');
            slTpEl.textContent = `SL: ${trade.stopLoss.toFixed(2)} | TP: ${trade.takeProfit.toFixed(2)}`;
            
            const reasonEl = document.createElement('p');
            reasonEl.textContent = trade.reason;
            
            tradeEl.appendChild(typeEl);
            tradeEl.appendChild(priceEl);
            tradeEl.appendChild(sizeEl);
            tradeEl.appendChild(slTpEl);
            tradeEl.appendChild(reasonEl);
            
            tradesContainer.insertBefore(tradeEl, tradesContainer.firstChild);
        }

        // Update trade in history UI
        function updateTradeInHistory(trade) {
            const tradeEl = document.querySelector(`.trade[data-id="${trade.id}"]`);
            if (!tradeEl) return;
            
            const pnlEl = document.createElement('div');
            pnlEl.className = trade.pnl > 0 ? 'profit' : 'loss';
            pnlEl.textContent = `PNL: ${trade.pnl.toFixed(2)} USDT (${((trade.pnl / (trade.entryPrice * trade.positionSize / tradingAccount.leverage)) * 100).toFixed(2)}%)`;
            
            const exitEl = document.createElement('div');
            exitEl.textContent = `Exit: ${trade.exitPrice.toFixed(2)} @ ${new Date(trade.exitTime).toLocaleTimeString()}`;
            
            if (trade.exitReason) {
                const reasonEl = document.createElement('div');
                reasonEl.textContent = trade.exitReason;
                reasonEl.style.fontSize = '0.8rem';
                reasonEl.style.opacity = '0.8';
                tradeEl.appendChild(reasonEl);
            }
            
            tradeEl.appendChild(pnlEl);
            tradeEl.appendChild(exitEl);
        }

        // Load trade history from localStorage
        function loadTradeHistory() {
            const history = localStorage.getItem('ethTradingHistory');
            if (history) {
                tradingAccount.trades = JSON.parse(history);
                tradingAccount.winCount = tradingAccount.trades.filter(t => t.pnl > 0).length;
                
                // Find any open positions
                const openPosition = tradingAccount.trades.find(t => t.status === 'open');
                if (openPosition) {
                    tradingAccount.currentPosition = openPosition;
                }
                
                // Display history
                tradingAccount.trades.slice().reverse().forEach(trade => {
                    const tradeEl = document.createElement('div');
                    tradeEl.className = 'trade';
                    tradeEl.dataset.id = trade.id;
                    
                    const typeEl = document.createElement('strong');
                    typeEl.textContent = trade.type.toUpperCase();
                    typeEl.className = trade.pnl > 0 ? 'profit' : 'loss';
                    
                    const priceEl = document.createElement('span');
                    priceEl.textContent = ` @ ${trade.entryPrice.toFixed(2)}`;
                    
                    const sizeEl = document.createElement('div');
                    sizeEl.textContent = `Size: ${(trade.positionSize / (trade.leverage || tradingAccount.leverage)).toFixed(4)} ETH`;
                    
                    if (trade.status === 'open') {
                        const slTpEl = document.createElement('div');
                        slTpEl.textContent = `SL: ${trade.stopLoss.toFixed(2)} | TP: ${trade.takeProfit.toFixed(2)}`;
                        tradeEl.appendChild(slTpEl);
                    } else {
                        const exitEl = document.createElement('div');
                        exitEl.textContent = `Exit: ${trade.exitPrice.toFixed(2)}`;
                        
                        const pnlEl = document.createElement('div');
                        pnlEl.className = trade.pnl > 0 ? 'profit' : 'loss';
                        pnlEl.textContent = `PNL: ${trade.pnl.toFixed(2)} USDT`;
                        
                        tradeEl.appendChild(exitEl);
                        tradeEl.appendChild(pnlEl);
                    }
                    
                    tradeEl.appendChild(typeEl);
                    tradeEl.appendChild(priceEl);
                    tradeEl.appendChild(sizeEl);
                    
                    tradesContainer.appendChild(tradeEl);
                });
            }
        }

        // Save trade history to localStorage
        function saveTradeHistory() {
            localStorage.setItem('ethTradingHistory', JSON.stringify(tradingAccount.trades));
        }

        // Load settings from localStorage
        function loadSettings() {
            const settings = localStorage.getItem('ethTradingSettings');
            if (settings) {
                tradingAccount.settings = JSON.parse(settings);
                
                // Apply settings
                tradingAccount.balance = tradingAccount.settings.accountSize;
                tradingAccount.riskPercentage = tradingAccount.settings.riskPercent;
                tradingAccount.leverage = tradingAccount.settings.leverage;
                tradingAccount.autoTrading = tradingAccount.settings.autoTrading;
                
                // Update UI
                accountSizeInput.value = tradingAccount.settings.accountSize;
                riskPercentInput.value = tradingAccount.settings.riskPercent;
                leverageSelect.value = tradingAccount.settings.leverage;
                autoTradingSelect.value = tradingAccount.settings.autoTrading;
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            tradingAccount.settings = {
                accountSize: parseFloat(accountSizeInput.value),
                riskPercent: parseFloat(riskPercentInput.value),
                leverage: parseInt(leverageSelect.value),
                autoTrading: autoTradingSelect.value
            };
            
            // Apply settings
            tradingAccount.balance = tradingAccount.settings.accountSize;
            tradingAccount.riskPercentage = tradingAccount.settings.riskPercent;
            tradingAccount.leverage = tradingAccount.settings.leverage;
            tradingAccount.autoTrading = tradingAccount.settings.autoTrading;
            
            localStorage.setItem('ethTradingSettings', JSON.stringify(tradingAccount.settings));
            updateAccountDisplay();
            
            // Show confirmation
            showMessage('Settings saved successfully!');
        }

        // Update account display
        function updateAccountDisplay() {
            balanceEl.textContent = tradingAccount.balance.toFixed(2);
            riskAmountEl.textContent = (tradingAccount.balance * (tradingAccount.riskPercentage / 100)).toFixed(2);
            tradeCountEl.textContent = tradingAccount.trades.length;
            
            const winRate = tradingAccount.trades.length > 0 
                ? Math.round((tradingAccount.winCount / tradingAccount.trades.length) * 100)
                : 0;
            winRateEl.textContent = winRate + '%';
            
            if (tradingAccount.currentPosition) {
                positionSizeEl.textContent = (tradingAccount.currentPosition.positionSize / tradingAccount.leverage).toFixed(4) + ' ETH';
                closePositionBtn.disabled = false;
                manualBuyBtn.disabled = true;
                manualSellBtn.disabled = true;
            } else {
                positionSizeEl.textContent = '0 ETH';
                closePositionBtn.disabled = true;
                manualBuyBtn.disabled = false;
                manualSellBtn.disabled = false;
            }
            
            leverageEl.textContent = tradingAccount.leverage + 'x';
        }

        // Check checklist completion
        function updateChecklistStatus() {
            const checkedCount = Array.from(checklistItems).filter(item => item.checked).length;
            autoTradeBtn.textContent = `Auto Trade (${checkedCount}/7)`;
            autoTradeBtn.disabled = checkedCount < 7;
        }

        // Show loading indicator
        function showLoading(message) {
            // Simple loading indicator for mobile
            const loading = document.createElement('div');
            loading.id = 'loading-indicator';
            loading.style.position = 'fixed';
            loading.style.top = '0';
            loading.style.left = '0';
            loading.style.right = '0';
            loading.style.bottom = '0';
            loading.style.backgroundColor = 'rgba(0,0,0,0.7)';
            loading.style.display = 'flex';
            loading.style.justifyContent = 'center';
            loading.style.alignItems = 'center';
            loading.style.zIndex = '1000';
            loading.style.color = 'white';
            loading.style.fontSize = '1.2rem';
            loading.textContent = message;
            
            document.body.appendChild(loading);
        }

        // Hide loading indicator
        function hideLoading() {
            const loading = document.getElementById('loading-indicator');
            if (loading) {
                loading.remove();
            }
        }

        // Show error message
        function showError(message) {
            const error = document.createElement('div');
            error.id = 'error-message';
            error.style.position = 'fixed';
            error.style.bottom = '20px';
            error.style.left = '20px';
            error.style.right = '20px';
            error.style.backgroundColor = '#ef4444';
            error.style.color = 'white';
            error.style.padding = '10px';
            error.style.borderRadius = '5px';
            error.style.zIndex = '1000';
            error.style.textAlign = 'center';
            error.textContent = message;
            
            document.body.appendChild(error);
            
            setTimeout(() => {
                error.remove();
            }, 5000);
        }

        // Show message
        function showMessage(message) {
            const msg = document.createElement('div');
            msg.id = 'status-message';
            msg.style.position = 'fixed';
            msg.style.bottom = '20px';
            msg.style.left = '20px';
            msg.style.right = '20px';
            msg.style.backgroundColor = '#10b981';
            msg.style.color = 'white';
            msg.style.padding = '10px';
            msg.style.borderRadius = '5px';
            msg.style.zIndex = '1000';
            msg.style.textAlign = 'center';
            msg.textContent = message;
            
            document.body.appendChild(msg);
            
            setTimeout(() => {
                msg.remove();
            }, 3000);
        }

        // Setup event listeners
        function setupEventListeners() {
            // Manual trade buttons
            manualBuyBtn.addEventListener('click', () => {
                executeTrade('buy', 'Manual buy order');
            });
            
            manualSellBtn.addEventListener('click', () => {
                executeTrade('sell', 'Manual sell order');
            });
            
            closePositionBtn.addEventListener('click', closePosition);
            
            // Checklist items
            checklistItems.forEach(item => {
                item.addEventListener('change', updateChecklistStatus);
            });
            
            // Timeframe buttons
            timeframeBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    timeframeBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTimeframe = btn.dataset.tf;
                    fetchInitialData();
                });
            });
            
            // Tab switching
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
                });
            });
            
            // Settings
            saveSettingsBtn.addEventListener('click', saveSettings);
            
            // Request notification permission
            if ('Notification' in window) {
                Notification.requestPermission().then(permission => {
                    console.log('Notification permission:', permission);
                });
            }
            
            // Handle visibility changes
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    // Refresh data when coming back to the tab
                    fetchInitialData();
                }
            });
        }

        // Periodically check for signals
        function startSignalCheckInterval() {
            setInterval(checkTradingSignals, 5000); // Check every 5 seconds
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
